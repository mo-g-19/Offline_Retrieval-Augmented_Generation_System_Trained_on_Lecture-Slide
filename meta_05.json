[
  {
    "doc": "05",
    "slide": "slide1",
    "text": "From Coulouris, Dollimore, Kindberg and Blair\nDistributed Systems: \n \n \nConcepts and Design\nEdition 5, \u00a9 Addison-Wesley 2012\nDistributed Objects and Components"
  },
  {
    "doc": "05",
    "slide": "slide2",
    "text": "Instructor\u2019s Guide for  Coulouris, Dollimore, Kindberg and Blair,  Distributed Systems: Concepts and Design   Edn. 5   \n\u00a9  Pearson Education 2012 \nDistributed object middleware\n\u2022\nThe key characteristic of distributed objects is that they allow you to \nadopt an object-oriented programming model for the development of \ndistributed systems\n\u2022\nCommunicating entities are represented by objects which \ncommunicate mainly using remote method invocation\n\u2022 The encapsulation\n\u2022 Data abstraction (programmers "
  },
  {
    "doc": "05",
    "slide": "slide3",
    "text": "Dr. Almetwally Mostafa\n3\nOUTLINE \nApplications\nMiddleware\nlayers\nrequest-reply protocol\nmarshalling and external data representation\nUDP and TCP\nThis\nchapter\nRMI, RPC, and events"
  },
  {
    "doc": "05",
    "slide": "slide4",
    "text": "4\nWhat\u2019s in a Name? \nDistributed Objects: \nSoftware modules (objects) that are designed to work together \nbut reside in multiple computer systems throughout an \norganization. A program in one machine sends a message to \nan object in a remote machine to perform some processing. \nThe results are sent back to the local machine."
  },
  {
    "doc": "05",
    "slide": "slide5",
    "text": "5\n\u201cThe Network is the Computer\u201d\nSomeClass\nAnotherClass\nmethod call\nreturned object\ncomputer 1\ncomputer 2"
  },
  {
    "doc": "05",
    "slide": "slide6",
    "text": "6\nWhat exactly do we mean by \u201cobjects\u201d?\nObjects are units of data with the following properties:\n\u25aatyped and self-contained\n\u2022 Each object is an instance of a type that defines a set of methods (signatures) that \ncan be invoked to operate on the object.\n\u25aaencapsulated\n\u2022\nThe only way to operate on an object is through its methods; the internal \nrepresentation/implementation is hidden from view.\n\u25aadynamically allocated/destroyed\n\u2022\nObjects are created as needed and destroyed when no longer needed, i.e."
  },
  {
    "doc": "05",
    "slide": "slide7",
    "text": "7\nInstructor\u2019s Guide for  Coulouris, Dollimore, Kindberg and Blair,  Distributed Systems: Concepts and Design   Edn. 5   \n\u00a9  Pearson Education 2012 \nDistributed objects\n7"
  },
  {
    "doc": "05",
    "slide": "slide8",
    "text": "8\nWhy are objects useful?\nThe properties of objects make them useful as a basis for \ndefining persistence, protection, and distribution.\n\u25aa\nObjects are self-contained and independent.\n\u25aaObjects are a useful granularity for persistence, caching, location, replication, \nand/or access control.\n\u25aa\nObjects are self-describing.\n\u25aaObject methods are dynamically bound, so programs can import and operate on \nobjects found in shared or persistent storage.\n\u25aa\nObjects are abstract and encapsulated.\n\u25aaIt is easy t"
  },
  {
    "doc": "05",
    "slide": "slide9",
    "text": "9\nIssues Vital to Distributed Object Systems\n1.\nCan we use distributed objects as a basis for interoperability among \nsoftware modules written in different languages?"
  },
  {
    "doc": "05",
    "slide": "slide10",
    "text": "Issues Vital to Distributed Object Systems\n10\n2.\nCan objects interact across systems with different data formats?"
  },
  {
    "doc": "05",
    "slide": "slide11",
    "text": "11\n3.\nHow can we recover object state after failures? \nIssues Vital to Distributed Object Systems\nhttps://www.youtube.com/watch?v=vhuYpnqFNoA"
  },
  {
    "doc": "05",
    "slide": "slide12",
    "text": "Example: Emerald\nEmerald is a classic and influential distributed \nobject system.\nDistribution is fully integrated into the language, its \nimplementation, and even its type model.\n\u2022\nThis is a strength and a weakness: combines language issues and \nsystem issues that should be separated.\nObjects can be freely moved around the network\n\u2022\nProgrammers see a uniform view of local and remote objects.\n\u2022\nMoving objects \u201ctake their code and threads with them\u201d.\nLocal invocation is fast; remote invocation is"
  },
  {
    "doc": "05",
    "slide": "slide13",
    "text": "Uniform Mobility: an Example\nnode A\nStep 1: a thread invokes a purple object \non node A, which  recursively invokes a \nblue object on the same node.\nnode A\nStep 2: the blue object moves to node B\nconcurrently with the invocation.\nnode B\nHow to preserve inter-object pointers across migration?\nHow to keep threads \u201csticky\u201d with migrating objects?\nHow to maintain references in stack activation records?\nHow to maintain linkages among activation records?"
  },
  {
    "doc": "05",
    "slide": "slide14",
    "text": "Object References in Emerald\nnode A\nEmerald represents inter-object references as pointers into an object \ndescriptor in an object table hashed by a unique object identifier (OID).\nThe object table has a descriptor for every resident object, and for every \nremote object referenced by a resident object, and then some.\nWhen an object moves, its containing references must be found (using \nits template) and updated to point to descriptors on the destination node.\nReferences to the moving object need"
  },
  {
    "doc": "05",
    "slide": "slide15",
    "text": "Distributed Objects Model\n\u25aa\nDistributed object systems adopt the client-server architecture:\n\u2022\nObjects are managed by servers and their clients invoke their \nmethods using remote method invocation.\n\u2022\nThe client\u2019s RMI request is sent in a message to the server managing \nthe invoked method object.\n\u2022\nThe method of the object at the server is executed and its result is \nreturned to the client in another message.\n\u2022\nObjects in servers are allowed to become clients of objects in other \nservers.\n\u25aa\nDistr"
  },
  {
    "doc": "05",
    "slide": "slide16",
    "text": "Distributed Objects Model\ninvocation\nremote\nA\nB\nC\nD\nE\nF\nRemote and local method invocations"
  },
  {
    "doc": "05",
    "slide": "slide17",
    "text": "Distributed Objects Model\n\u2022\nEach process contains a collection of objects, some of which can \nreceive both local and remote invocations and others can receive \nonly local invocations.\n\u2022\nObjects that can receive remote invocations are called remote \nobjects.\n\u2022\nOther objects need to know the remote object reference in another \nprocess in order to invoke its methods.\n\u2022\nA remote object reference is an identifier that can be used through a \ndistributed system to refer to a particular unique remote ob"
  },
  {
    "doc": "05",
    "slide": "slide18",
    "text": "23\nDistributed Object Technologies\n1.\nRemote Method Invocation (RMI)\nAPI and architecture for distributed Java objects\n2.\nMicrosoft Component Object Model (COM/DCOM)\nbinary standard for distributed objects for Windows platforms\n3.\nCORBA (Common Object Request Broker Architecture)\nplatform and location transparency for sharing well-defined objects across a \ndistributed computing platform\n4.\nEnterprise Java Beans (EJB)\nCORBA-compliant distributed objects for Java, built using RMI\n5.\nWeb services a"
  },
  {
    "doc": "05",
    "slide": "slide19",
    "text": "Example: RMI and Network Objects\nOur goal now is to look at some current distributed object \nsystems.\nWe start with systems that preserve the single-language \nmodel of Emerald, with uniform garbage collection:\n\u2022\nRMI for Java"
  },
  {
    "doc": "05",
    "slide": "slide20",
    "text": "Stub/Surrogate Objects\nserver\nRemote objects are referenced through proxy \nor surrogate objects, which \u201cmasquerade\u201d as \nthe actual remote object.\nclient\n[SOS system, Marc Shapiro, The Proxy Principle (1986)]\nstub, surrogate, or proxy\nskeleton or guard\nProxy/stub objects can enscapsulate caching, replication, or other aspects of distribution that are \nbest kept hidden from the client (also cf. subcontracts [Hamilton et. al., SOSP 93]).\nSkeletons/guards may\nperform access checks\nas well as marshal"
  },
  {
    "doc": "05",
    "slide": "slide21",
    "text": "Remote Method Invocation (RMI)\n3: stub2 = stub1->method()\nstub\nRMI layer\ntransport\nskeleton\nRMI layer\ntransport\nclient VM\nserver VM\nRMI registry\n2: stub1  = Naming.lookup(URL)\n1: Naming.bind(URL, obj1)\nThe registry provides a bootstrap \nnaming service using URLs.\nrmi://slowww.server.edu/object1\nobj1\nobj2\nobj3\nRMI is \u201cRPC in Java\u201d, supporting \nEmerald-like distributed object \nreferences, invocation, and garbage \ncollection, derived from SRC Modula-3\nnetwork objects [SOSP 93].\nserver app\nclient ap"
  },
  {
    "doc": "05",
    "slide": "slide22",
    "text": "The RMI Stack\nstub\nRMI layer\ntransport\nskeleton\nRMI layer\ntransport\nclient VM\nserver VM\nserver app\nclient app\ncached TCP\nconnections\ncached server\nthreads\nobject table\nobject table\nreferenced set\nmethod stubs\nreferenced set\nmethod stubs"
  },
  {
    "doc": "05",
    "slide": "slide23",
    "text": "\u25aa\nVery similar to a remote method invocation\n\u2022\nA client process calls a procedure in a server process.\n\u2022\nServers may be clients of other servers to allow chains of RPCs.\n\u2022\nImplemented to have one of the choices of invocation semantics.\n\u2022\nImplemented over a request-reply protocol .\n\u25aa\nThe contents of request and reply messages are the same as RMI except \nthat the object reference field is omitted.\n\u25aa\nThe supported software is similar except that no remote reference modules \nare required and client "
  },
  {
    "doc": "05",
    "slide": "slide24",
    "text": "Remote Procedure Call (RPC)\nclient \nRequest\nReply\nCommunication\nCommunication\nmodule\nmodule\ndispatcher\nservice \nclient stub\nserver stub\nprocedure\nprocedure\nclient process \nserver process \nprocedure\nprogram \nRole of client and server stub procedures in RPC"
  },
  {
    "doc": "05",
    "slide": "slide25",
    "text": "32\nJAVA RMI Example"
  },
  {
    "doc": "05",
    "slide": "slide26",
    "text": "33\nIntroduction to Java RMI\nJava RMI allowed programmer to execute remote function class using the \nsame semantics as local functions calls.\nLocal Machine (Client)\nSampleServer remoteObject;\nint s;\n\u2026\ns = remoteObject.sum(1,2);\nSystem.out.println(s);\nRemote Machine (Server)\npublic int sum(int a,int b) \n{\n     return a + b;\n}\n1,2\n3"
  },
  {
    "doc": "05",
    "slide": "slide27",
    "text": "34\nThe General RMI Architecture\nLocal/Remote machines\nRegistry\nSkeleton\nStub\nRMI Server\nskeleton\nstub\nRMI Client\nRegistry\nbind\nlookup\nreturn\ncall\nLocal Machine\nRemote Machine"
  },
  {
    "doc": "05",
    "slide": "slide28",
    "text": "35\nThe Stub and Skeleton\nA client invokes a remote method, the call is first forwarded to stub. The stub is \nresponsible for sending the remote call over to the server-side skeleton\nThe stub opening a socket to the remote server, marshaling (encoding in standard, \nindependent format) the object parameters and forwarding the data stream to the skeleton.\nA skeleton contains a method that receives the remote calls, unmarshals the parameters, \nand invokes the actual remote object implementation.\nStu"
  },
  {
    "doc": "05",
    "slide": "slide29",
    "text": "36\nSteps for Developing an RMI System\n1. Define the remote interface\n2. Develop the remote object by implementing the remote \ninterface\n3. Develop the client program\n4. Compile the Java source files\n5. Generate the client stubs and server skeletons\n6. Start the RMI registry\n7. Start the remote server objects\n8. Run the client"
  },
  {
    "doc": "05",
    "slide": "slide30",
    "text": "37\nStep 1:  Defining the Remote Interface\nTo create an RMI application, the first step is the defining of a \nremote interface between the client and server objects.\n/* SampleServer.java */\nimport java.rmi.*;\npublic interface SampleServer extends Remote\n{\n  public int sum(int a,int b) throws RemoteException;\n}"
  },
  {
    "doc": "05",
    "slide": "slide31",
    "text": "38\nStep 2: Develop the Remote Object and its Interface\nThe server is a simple unicast remote server. \nCreate server by extending java.rmi.server.UnicastRemoteObject. \n/* SampleServerImpl.java */\nimport java.rmi.*;\nimport java.rmi.server.*;\nimport java.rmi.registry.*;\npublic class SampleServerImpl extends UnicastRemoteObject implements SampleServer\n{\n  SampleServerImpl() throws RemoteException\n  {\n     super();\n  }\n\u2026"
  },
  {
    "doc": "05",
    "slide": "slide32",
    "text": "39\nStep 2: Develop the remote object and its interface\nImplement the remote methods\n/* SampleServerImpl.java */\n  \u2026\n  public int sum(int a,int b) throws RemoteException\n  {\n     return a + b;\n  }\n}"
  },
  {
    "doc": "05",
    "slide": "slide33",
    "text": "40\nStep 2: Develop the remote object and its interface\n/* SampleServerImpl.java */\n  public static void main(String args[])\n  {\n      try\n      {\n \n//set the security manager\n        System.setSecurityManager(new RMISecurityManager());\n        //create a local instance of the object\n        SampleServerImpl Server = new SampleServerImpl();\n        //put the local instance in the registry\n        Naming.rebind(\"SAMPLE-SERVER\" , Server);\n        System.out.println(\"Server waiting.....\");\n      }\n "
  },
  {
    "doc": "05",
    "slide": "slide34",
    "text": "41\nStep 3: Develop the client program\nIn order for the client object to invoke methods on the server, it must first \nlook up the name of server in the registry. You use the java.rmi.Naming \nclass to lookup the server name.\nThe server name is specified as URL in the form (rmi://host:port/name )\nDefault RMI port is 1099.\nThe name specified in the URL must exactly match the name that the server \nhas bound to the registry. In this example, the name is \u201cSAMPLE-\nSERVER\u201d\nThe remote method invocation is"
  },
  {
    "doc": "05",
    "slide": "slide35",
    "text": "42\nStep 3: Develop the client program\nimport java.rmi.*;\nimport java.rmi.server.*;\npublic class SampleClient  \n{\n   public static void main(String[]  args)\n   {\n      // set the security manager for the client\n      System.setSecurityManager(new RMISecurityManager());\n      //get the remote object from the registry\n      try\n        {\n          System.out.println(\"Security Manager loaded\");\n          String url = \"//localhost/SAMPLE-SERVER\";\n          SampleServer remoteObject = (SampleServer)Na"
  },
  {
    "doc": "05",
    "slide": "slide36",
    "text": "43\nStep 4 & 5: Compile the Java source files & Generate the client \nstubs and server skeletons\nOnce the interface is completed, you need to generate \nstubs and skeleton code. The RMI system provides \nan RMI compiler (rmic) that takes your generated \ninterface class and procedures stub code on its self.\njavac SampleServer.java\njavac SampleServerImpl.java\nrmic SampleServerImpl\njavac SampleClient.java"
  },
  {
    "doc": "05",
    "slide": "slide37",
    "text": "44\nStep 6: Start the RMI registry\nRMI Registry must be started manually.\nThe rmiregistry us uses port 1099 by default. You can also bind rmiregistry \nto a different port by indicating the new port number as : rmiregistry <new \nport>\n \n \nrmiregistry (Unix)\n \n \nstart rmiregistry (Windows)"
  },
  {
    "doc": "05",
    "slide": "slide38",
    "text": "45\nSteps 7 & 8: Start the remote server objects & Run the client\nOnce the Registry is started, start the server. \nSet the security policy\njava \u2013Djava.security.policy=policy.all SampleServerImpl\njava \u2013Djava.security.policy=policy.all SampleClient\nMore at http://www.neward.net/ted/Papers/JavaPolicy/"
  }
]