[
  {
    "doc": "lecture03_processed.json",
    "id": "slide1",
    "text": "From Coulouris, Dollimore, Kindberg and Blair\nDistributed Systems: \n \n \nConcepts and Design\nEdition 5, © Addison-Wesley 2012\nInterprocess Communication\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide2",
    "text": "Instructor’s Guide for  Coulouris, Dollimore, Kindberg and Blair,  Distributed Systems: Concepts and Design   Edn. 5   \n©  Pearson Education 2012 \nThe characteristics of interprocess communication\n• Messages are sent to (Internet address, local port) pairs.\n• A port has exactly one receiver but can have many senders\n• Processes may use multiple ports to receive messages\n• Validity: A point-to-point message service is reliable if messages are \nguaranteed to be delivered despite packet drop\n• Integrity: Messages must arrive uncorrupted and without duplication\n• Ordering: messages be delivered in sender order\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide3",
    "text": "Sockets \nApplication and middleware layers use \nthe services provided by the network and \ntransport layers through socket API.\nFrom Computer Networking by Kurose and Ross.\napplication\ntransport\nnetwork\nlink\nphysical\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide4",
    "text": "4\nSocket programming\nSocket API\n•\nintroduced in BSD4.1 UNIX, \n1981\n•\nexplicitly created, used, \nreleased by apps \n•\nclient/server paradigm \n•\ntwo types of transport service \nvia socket API: \n•\nunreliable datagram \n•\nreliable, byte stream-oriented \na host-local, \napplication-created, \nOS-controlled interface \n(a “door”) into which\napplication process can \nboth send and \nreceive messages to/from \nanother application \nprocess\nsocket\nGoal: learn how to build client/server application that \ncommunicate using sockets\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide5",
    "text": "Processes-to-process communication\nProcess: program running \nwithin a host.\nwithin same host, two \nprocesses communicate \nusing inter-process \ncommunication (shared \nmemory defined by OS).\nprocesses in different hosts \ncommunicate by \nexchanging messages \nusing transport layer\nClient process: process \nthat initiates \ncommunication\nServer process: process \nthat waits to be \ncontacted\nNote: applications \nwith P2P architectures \nhave client processes \n& server processes\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide6",
    "text": "Addressing processes\nto receive messages, \nprocess must have \nidentifier\nhost device has unique 32-\nbit IP address\nQ: does IP address of host \non which process runs \nsuffice for identifying the \nprocess?\nA: No, many processes can \nbe running on the same \nhost\nidentifier includes both IP \naddress and port number \nassociated with the process \nWhat is a port number?\n16 bits integer used by transport layer \nto identify end points (processes) \non a host\nwell-known ports:  1 – 1023 Telnet 23; FTP \n21; HTTP 80\nregistered ports: 1024 – 49151 \ndynamic or private ports: 49152 - \n65535 \nTo communicate, client must know the server’s IP address, and port number. \nHow will the server know the client’s IP address and port number? \nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide7",
    "text": "Sockets\nAPI, an interface, gate, door \nbetween a process and \ntransport layer\nA socket must be bound to a \nlocal port\nIs (IP addr, port) enough to \nidentify a socket?\nprocess\nTCP with\nbuffers,\nvariables\nsocket\nhost or\nserver\nprocess\nTCP with\nbuffers,\nvariables\nsocket\nhost or\nserver\nInternet\ncontrolled\nby OS\ncontrolled by\napp developer\nmessage\nagreed port\nany port\nsocket\nsocket\nInternet address = 138.37.88.249\nInternet address = 138.37.94.248\nother ports\nclient\nserver\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide8",
    "text": "Socket-programming using TCP\nSocket: a door between application process and end-\nend-transport protocol (UCP or TCP)\nTCP service: reliable transfer of bytes from one process \nto another\nprocess\nTCP with\nbuffers,\nvariables\nsocket\ncontrolled by\napplication\ndeveloper\ncontrolled by\noperating\nsystem\nhost or\nserver\nprocess\nTCP with\nbuffers,\nvariables\nsocket\ncontrolled by\napplication\ndeveloper\ncontrolled by\noperating\nsystem\nhost or\nserver\ninternet\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide9",
    "text": "Socket programming with TCP\nClient must contact server\n•\nserver process must first be \nrunning\n•\nserver must have created \nsocket (door) that welcomes \nclient’s contact\nClient contacts server by:\n•\ncreating client-local TCP \nsocket\n•\nspecifying IP address, port \nnumber of server process\n•\nWhen client creates socket: \nclient TCP establishes \nconnection to server TCP\nWhen contacted by client, server \nTCP creates new socket for \nserver process to \ncommunicate with client\n•\nallows server to talk with \nmultiple clients\n•\nsource port numbers used to \ndistinguish clients\nTCP provides reliable, in-order\n transfer of bytes (“pipe”) \nbetween client and server\napplication viewpoint\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide10",
    "text": "Socket with TCP\n10\nWeb server has two sockets opened: one for each web \npage it is serving. These sockets are differentiated by the \ndestination port numbers.\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide11",
    "text": "Client/server socket interaction: TCP\nServer (stand-by, waiting for requests)\nClient (initiate the request) \nCreate socket\n(Claim resources/ available phone)\nBind port\n(Claim ID on this machine/ \nget a phone extension No.)\nListen/ accept\n(Wait for connections/ Wait for phone call)\nSend/ receive\n(Communication/ Chat on phone)\nCreate socket\n(Claim resources/ available phone)\nConnect\n(connect to server/ call others)\n-\n(Don’t care about public port/ phone #)\nSend/ receive\n(Communication/ Chat on phone)\nClose socket\n(End communication/ Hang up the phone)\nClose socket\n(End communication/ Hang up the phone)\n1\n2\n3\n4\n5\n6\n6\n7/8\n7/8\nRed word: wait for the other side\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide12",
    "text": "TCP Socket Primitives\nPrimitive\nFunction\nSocket\nCreate a new communication endpoint\nBind\nAttach a local address to a socket\nListen\nAnnounce willingness to accept connections\nAccept\nBlock caller until a connection request arrives\nConnect\nActively attempt to establish a connection\nSend\nSend some data over the connection\nRecv\nReceive some data over the connection\nClose\nRelease the connection\nConnection \nsocket\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide13",
    "text": "Client/server socket interaction: TCP\nServer (stand-by, waiting for requests)\nClient (initiate the request) \nCreate socket\n(Claim resources/ available phone)\nBind port\n(Claim ID on this machine/ \nget a phone extension No.)\nListen/ accept\nSend/ receive\n(Communication/ Chat on phone)\nCreate socket\n(Claim resources/ available phone)\nConnect\n(connect to server/ call others)\nSend/ receive\n(Communication/ Chat on phone)\nClose socket\n(End communication/ Hang up the phone)\nClose socket\n(End communication/ Hang up the phone)\nFork/ New thread\nChild\nParent\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide14",
    "text": "Client/server socket interaction: TCP\nwait for incoming\nconnection request\nconnectionSocket =\nwelcomeSocket.accept()\ncreate socket,\nport=x, for\nincoming request:\nwelcomeSocket = \nServerSocket()\ncreate socket,\nconnect to hostid, port=x\nclientSocket = \nSocket()\nclose\nconnectionSocket\nread reply from\nclientSocket\nclose\nclientSocket\nServer (running on hostid, port x)\nClient (running on hostname ?, port ?)\nsend request using\nclientSocket\nread request from\nconnectionSocket\nwrite reply to\nconnectionSocket\nTCP \nconnection setup\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide15",
    "text": "15\nConnection-oriented TCP\n❑TCP socket identified by 4-tuple: \n•\nsource IP address\n•\nsource port number\n•\ndestion IP address\n•\ndestion port number\n❑Receive host uses all four values to direct \nsegment to appropriate socket\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide16",
    "text": "Socket programming with UDP\nUDP: no “connection” between\nclient and server\n•\nno handshaking\n•\nsender explicitly attaches IP \naddress and port of \ndestination\n•\nserver must extract IP \naddress, port of sender from \nreceived datagram\nUDP: transmitted data may be\nreceived out of order, or lost\nUDP provides unreliable transfer\nof groups of bytes (“datagrams”)\nbetween client and server\napplication viewpoint\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide17",
    "text": "Socket programming with UDP\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide18",
    "text": "Multicast Communication \nAt Network Layer\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide19",
    "text": "Unicast Communication \nIn unicast routing, the router forwards \nthe received packet through only one \nof its interfaces.\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide20",
    "text": "Multicast Communication \nBroadcast – sends a single message from one \nprocess to all processes (hosts)\n• Used for ARP in a LAN\n• Hard and expensive in WAN\nMulticast – sends a single message from one \nprocess to members of a group of processes \n(hosts)\nWho needs multicast?\nWho should provide it?\n Application, transport, network layer? \nhttps://www.youtube.com/watch?v=C5pFaZtbISo \n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide21",
    "text": "Multicast Communication \n• In multicast \nrouting, the \nrouter may \nforward the \nreceived packet \nthrough several \nof its interfaces\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide22",
    "text": "Who needs it?\nUses of Multicast and Its Effects\nFault tolerance based on replicated services\n• Requests multicast to group of servers\nDiscovery in spontaneous networking\n• Locate available discovery services\nPerformance from replicated data\n• Multicast changes to all replicas\nPropagation of event notifications in a distributed \nenvironment\n• News group: news → group of interested users\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide23",
    "text": "Multicast IP address\noc tet 1\noc tet 2\noc tet 3\nClass  A:\n1 to 127\n0 to 255\n0 to 255\n1 to 254\nClass  B:\n128 to 191\nClass  C:\n192 to 223 \n224 to 239 \nClass  D (multicast) :\nNetwork  ID\nNetwork  ID\nNetwork  ID\nHost ID\nHost ID\nHost ID\nMultic ast addres s\n0 to 255\n0 to 255\n1 to 254\n0 to 255\n0 to 255\n0 to 255\n0 to 255\n0 to 255\n0 to 255\nMultic ast addres s\n0 to 255\n0 to 255\n1 to 254\n240 to 255 \nClass  E ( res erv ed) :\n1.0.0.0 to \n127.255.255.255\n128.0.0.0 to \n191.255.255.255\n192.0.0.0 to \n223.255.255.255\n224.0.0.0 to \n239.255.255.255\n128.0.0.0 to \n247.255.255.255\nRange of addresses\n224.0.0.0 to 224.0.0.255 (224.0.0.0/24) → local subnet multicast traffic \n224.0.1.0 to 238.255.255.255 → globally scoped addresses \n239.0.0.0 to 239.255.255.255 (239.0.0.0/8) → administratively scoped \naddresses, boundary\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide24",
    "text": "IP Multicast Process\nEach multicast address → identify a group\nInternet Group Membership Protocol (IGMP)\n• Processes register a group with local router using IGMP\nRouter update its multicast routing table\nProcesses send message to a group\n• Do not need to be a member\nRouter forward multicast messages\n"
  },
  {
    "doc": "lecture03_processed.json",
    "id": "slide25",
    "text": "Multicast Routing Problem\nGoal: find a tree (or trees) connecting routers \nhaving local multicast group members \ntree: not all paths between routers used\nsource-based: different tree from each sender to receivers\nshared-tree: same tree used by all group members\nShared tree\nSource-based trees\nFrom Computer Networking by Kurose and Ross.\n"
  }
]