[
  {
    "doc": "lecture02_processed.json",
    "id": "slide1",
    "text": "Chapter 3: \nNetworking and Internetworking\n§ Concepts\n§ Switching\n§ Routing (IP)\n§ End-to-End Protocols (UDP/TCP)\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide2",
    "text": "Fundamentals\nMany different agreements (protocols) are needed \nat various levels\nApplication-level agreements\nBit representation to meaning of each message \nOther-levels and agreements \nHow to actually transmit messages through a network \nAddressing, performance, scalability, reliability, security\nA\nB\nOS\nOS\nHow can A and B communicate?\nnetwork\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide3",
    "text": "What’s Network (the Internet)?\n To learn more, take CECS 303\nNetwork of networks connecting \nmillions of devices: \nHosts (end systems)\nLinks (fiber to satellite)\nRouters and switches\nCollection of protocols providing \ncommunication services to \ndistributed applications  \nNetworks are complex!\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide4",
    "text": "Switched Networks\ntwo or more nodes \nconnected by a link, \nor\ntwo or more \nnetworks connected \nby a node\nA network can be defined recursively as...\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide5",
    "text": "Types of Networks\nhttps://www.youtube.com/watch?v=HLziLmaYsO0 \n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide6",
    "text": "Protocols and Layers\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide7",
    "text": "Conceptual layering of protocol software\nLayer n\nLayer 2\nLayer 1\nMessage sent\nMessage received\nCommunication\nmedium\nSender\nRecipient\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide8",
    "text": "Protocol layers in the ISO Open Systems Interconnection (OSI) model\n!\"\"#A%CDA()\n*+,-,)DCDA()\n.,--A()\nL+C)-\"(+D\nM,DN(+2\nPCDC4#A)2\n*RS-A%C#\nT,--C8,4-,)D\nT,--C8,4+,%,A9,:\n.,):,+\n;,%A\"A,)D\n<CS,+-\n=(>>?)A%CDA()\n>,:A?>\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide9",
    "text": "Internet protocol stack\napplication: Protocols that are designed to \nmeet the communication requirements of \nspecific applications, often defining the \ninterface to a service. (FTP, HTTP)\ntransport: process-to-process data \ntransfer (TCP, UDP)\nnetwork: routing of datagrams from \nsource to destination (IP, OSPF, BGP)\nlink: data transfer between neighboring  \nnetwork elements (PPP, Ethernet)\nphysical: transmission of bits on a link \n(electrical signals on cable, light signals on fibre or \nother electromagnetic signals on radio) \napplication\ntransport\nnetwork\nlink\nphysical\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide10",
    "text": "ISO/OSI reference model\npresentation: allow applications to \ninterpret meaning of data, e.g., \nencryption, compression, machine-\nspecific conventions\nsession: synchronization, check \npointing, recovery of data exchange\napplication\npresentation\nsession\ntransport\nnetwork\nlink\nphysical\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide11",
    "text": "What is OSI mode?\nhttps://www.youtube.com/watch?v=Ilk7UXzV_Qc\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide12",
    "text": "ISO Architecture\n!\"#A%&AD%&#A\"%E#)\n*+,-+\"A,-#A\"#,*%&.\n/\"EA-%),\n0NNO+P4,+%\"\n5&#)#\",4,+%\"\nS#))+%\"\nT&4\")N%&,\n8#,*%&.\n94,4AO+\".\n5-:)+P4O\n8#,*%&.\n94,4AO+\".\n5-:)+P4O\n8#,*%&.\n94,4AO+\".\n5-:)+P4O\n/\"EA-%),\n0NNO+P4,+%\"\n5&#)#\",4,+%\"\nS#))+%\"\nT&4\")N%&,\n8#,*%&.\n94,4AO+\".\n5-:)+P4O\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide13",
    "text": "Encapsulation as it is applied in layered protocols\n!\"#A#%&'&()%*+#',#\"\n-../(0'&()%N/'2#\"*P#AA'4#\n5#AA()%*+#',#\"\nS\"'%A.)\"&*+#',#\"\nT#&8)\"9*+#',#\"\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide14",
    "text": "The interaction between layers in the OSI model\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide15",
    "text": "An exchange using the OSI model\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide16",
    "text": "Summary of layers\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide17",
    "text": "TCP/IP layers\nMessages (UDP) or Streams (TCP)\nApplication\nTransport\nInternet\nUDP or TCP packets\nIP datagrams\nNetwork-specific frames\nMessage\nLayers\nUnderlying network\nNetwork  interface\nLink Layer\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide18",
    "text": "TCP/IP and OSI model\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide19",
    "text": "Encapsulation in a message transmitted via TCP over an Ethernet\nApplication message\nTCP header\nIP header\nEthernet header\nEthernet frame\nport\nTCP\nIP\nhttps://www.youtube.com/watch?v=OTwp3xtd4dg \n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide20",
    "text": "The programmer's conceptual view of a TCP/IP Internet\n!\"\n#AA%CD()C*+\n#AA%CD()C*+\nI-\"\n./\"\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide21",
    "text": "source\napplication\ntransport\nnetwork\nlink\nphysical\nHt\nHn\nM\nsegment\nHt\npackets\ndestination\napplication\ntransport\nnetwork\nlink\nphysical\nHt\nHn\nHl\nM\nHt\nHn\nM\nHt\nM\nM\nnetwork\nlink\nphysical\nlink\nphysical\nHt\nHn\nHl\nM\nHt\nHn\nM\nHt\nHn\nM\nHt\nHn\nHl\nM\nrouter\nswitch\nEncapsulation\nmessage\nM\nHt\nM\nHn\nframe\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide22",
    "text": "OSI vs TCP/IP\nOSI Model\nTCP/IP model\nIt is developed by ISO (International Standard \nOrganization)\nIt is developed by ARPANET (Advanced Research Project \nAgency Network).\nOSI model provides a clear distinction between \ninterfaces, services, and protocols.\nTCP/IP doesn’t have any clear distinguishing points \nbetween services, interfaces, and protocols.\nOSI refers to Open Systems Interconnection.\nTCP refers to Transmission Control Protocol.\nOSI uses the network layer to define routing standards \nand protocols.\nTCP/IP uses only the Internet layer.\nOSI follows a vertical approach.\nTCP/IP follows a horizontal approach.\nOSI use two separate layers physical and data link to \ndefine the functionality of the bottom layers.\nTCP/IP uses only one layer (link).\nOSI layers have seven layers.\nTCP/IP has five layers.\nOSI model, the transport layer is only connection-\noriented.\nA layer of the TCP/IP model is both connection-oriented \nand connectionless.\nIn the OSI model, the data link layer and physical are \nseparate layers.\nIn TCP, physical and data link are both combined as a \nsingle host-to-network layer.\nSession and presentation layers are not a part of the \nTCP model.\nThere is no session and presentation layer in TCP model.\nIt is defined after the advent of the Internet.\nIt is defined before the advent of the internet.\nThe minimum size of the OSI header is 5 bytes.\nMinimum header size is 20 bytes.\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide23",
    "text": "Why layering?\nExplicit structure allows identification, relationship of \ncomplex system’s pieces\nEach layer \n\ngets a service from the one below, \n\nperforms a specific task, and \n\nprovides a service to the one above \nModularization eases maintenance and updating of system\nWe can change the implementation of a layer without \naffecting the rest of the system as long as the interfaces \nbetween the layer are kept the same!\nIn some cases, layering considered harmful! Why?\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide24",
    "text": "Routing (IP)\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide25",
    "text": "IP Addressing: introduction\nIP address: 32-bit \nunique identifier for \nhost, router interface \ninterface: connection \nbetween host/router \nand physical link\n\nrouter’s typically have \nmultiple interfaces\n\nhost typically has one \ninterface\n\nIP addresses associated \nwith each interface\n223.1.1.1\n223.1.1.2\n223.1.1.3\n223.1.1.4\n223.1.2.9\n223.1.2.2\n223.1.2.1\n223.1.3.2\n223.1.3.1\n223.1.3.27\n223.1.1.1 = 11011111 00000001 00000001 00000001\n223\n1\n1\n1\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide26",
    "text": "Internet address structure, showing field sizes in bits\n!\n\"#\nABCDDE)*\nH\nI-./MN2E34\n5MD.E34\n6#\n67\nABCDDE8*\n6\nH\nI-./MN2E34\n5MD.E34\n\"6\n9\nABCDDEA*\n6\n6\nH\nI-./MN2E34\n5MD.E34\n\"9\nABCDDE4E:;<B.=>CD.?*\n6\n6\n6\nH\n@<B.=>CD.ECAAN-DD\n\"!\nABCDDEBE:N-D-NC-A?*\n6\n6\n6\n6\n<a<D-A\nH\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide27",
    "text": "Decimal representation of Internet addresses\noctet 1\noctet 2\noctet 3\nClass A:\n1 to 127\n0 to 255\n0 to 255\n1 to 254\nClass B:\n128 to 191\nClass C:\n192 to 223 \n224 to 239 \nClass D (multicast):\nNetwork ID\nNetwork ID\nNetwork ID\nHost ID\nHost ID\nHost ID\nMulticast address\n0 to 255\n0 to 255\n1 to 254\n0 to 255\n0 to 255\n0 to 255\n0 to 255\n0 to 255\n0 to 255\nMulticast address\n0 to 255\n0 to 255\n1 to 254\n240 to 255 \nClass E (reserved):\n1.0.0.0 to \n127.255.255.255\n128.0.0.0 to \n191.255.255.255\n192.0.0.0 to \n223.255.255.255\n224.0.0.0 to \n239.255.255.255\n240.0.0.0 to \n255.255.255.255\nRange of addresses\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide28",
    "text": "IPv4 Packet Header\n\nVersion (always set to the value 4 for IPv4) \n\nIP Header Length (number of 32 -bit words forming the header, \nusually five) \n\nSize of Datagram (in bytes, header + data) \n\nFlags 3 bits: R (reserved bit set to 0) DF (Don't fragment ) MF (More \nfragments) \n\nTime To Live (Number of hops /links which the packet may be \nrouted over, decremented by most routers - used to prevent \naccidental routing loops) \n\nProtocol (the type of transport packet being carried (e.g. 1 = \nICMP; 6 = TCP; 17= UDP). \n\nHeader Checksum (A 1's complement checksum of IP header, \nupdated whenever the packet header is modified by a node. \nPackets with an invalid checksum are discarded by all nodes in \nan IP network) \n\nSource Address / Destination Address\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide29",
    "text": "Example of IP Packet\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide30",
    "text": "Every datagram packet contains destination’s \naddress\nif connected to destination network, then forward \nto the host in LAN\nIf network number of destination IP == my network \nnumber\nif not directly connected, then forward to the \nhost’s default router\nEach router maintains a forwarding table\nforwarding table maps network number (rather than \nhost address) into next hop or interface number (if \ndirectly connected)\nDatagram Forwarding Strategy\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide31",
    "text": "An Example of Routing\nA packet is submitted to Router A and destination is C, \nhow to routing?\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide32",
    "text": "Addressing and Routing\nAddress: byte-string that identifies a node\nusually unique\nRouting: process of forwarding messages to the \ndestination node based on its address\nTypes of addresses\nunicast: node-specific\nbroadcast: all nodes on the network\nmulticast: some subset of nodes on the network\nhttps://www.youtube.com/watch?v=gQtgtKtvRdo\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide33",
    "text": "Address Translation in LAN\nMap IP addresses into physical addresses of the \ndestination host (if connected directly) or the next hop \nrouter\nARP (Address Resolution Protocol)\n\nEach host caches its table of IP to physical address bindings\n\ntable entries are discarded if not refreshed\n\ntimeout in about 10 minutes\n\nbroadcast request if IP address not in table\n\ntarget machine send its physical address to the sender \n\ntarget machine also updates add entry of the source in its table\n\nIt is likely that the target will send IP packets to the source later on.\n\nOther hosts (who receives the broadcasted request) update \ntable if already have an entry\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide34",
    "text": "Addressing: routing to another LAN\nR\n1A-23-F9-CD-06-9B\n222.222.222.220\n111.111.111.110\nE6-E9-00-17-BB-4B\nCC-49-DE-D0-AB-7D\n111.111.111.112\n111.111.111.111\nA\n74-29-9C-E8-FF-55\n222.222.222.221\n88-B2-2F-54-1A-0F\nB\n222.222.222.222\n49-BD-D2-C7-56-2A\nwalkthrough: send datagram from A to B via R\n                     assume  A knows B’s IP address\ntwo ARP tables in  router R, one for each IP network (LAN)\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide35",
    "text": "Network layer\nforwarding\ntable\nHost, router network layer functions:\nRouting protocols\n•path selection\n•RIP, OSPF, BGP\nIP protocol\n•addressing conventions\n•datagram format\n•packet handling conventions\nICMP protocol\n•error reporting\n•router “signaling”\nTransport layer: TCP, UDP\nLink layer\nphysical layer\nNetwork\nlayer\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide36",
    "text": "1\n2\n3\n0111\nvalue in arriving\npacket’s header\nrouting algorithm\nlocal forwarding table\nheader value\noutput link\n0100\n0101\n0111\n1001\n3\n2\n2\n1\nForwarding Problem: Where to Send Next?\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide37",
    "text": "Only IPv4? No, we need more!\nhttps://www.youtube.com/watch?v=bNmnRvZW3HU \n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide38",
    "text": "IPv6\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide39",
    "text": "End-to-End Protocols\n(UDP/TCP)\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide40",
    "text": "End-to-End Protocols\nUnderlying best-effort network\n\ndrop messages\n\nre-orders messages\n\ndelivers duplicate copies of a given message\n\nlimits packet (not message) to some finite size\n\ndelivers messages after an arbitrarily long delay\nCommon end-to-end services\n\nguarantee message delivery\n\ndeliver messages in the same order they are sent\n\ndeliver at most one copy of each message\n\nsupport arbitrarily large messages\n\nsupport synchronization between sender and receiver\n\nallow the receiver to flow control the sender\n\nsupport multiple application processes on each host\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide41",
    "text": "Transport Layer \n\nprovide logical communication \nbetween app processes running \non different hosts\n\ntransport protocols run in end \nsystems \n\nsender side: breaks app \nmessages into segments, \npasses to network layer\n\nreceiver side: reassembles \nsegments into messages, \npasses to app layer\n\nmore than one transport \nprotocol available to apps\n\nInternet: TCP and UDP\napplication\ntransport\nnetwork\ndata link\nphysical\napplication\ntransport\nnetwork\ndata link\nphysical\nlogical end-end transport\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide42",
    "text": "Internet transport protocols services\nTransmission Control Protocol \n(TCP) service:\n\nconnection-oriented: setup \nrequired between client and \nserver processes\n\nreliable transport between \nsending and receiving process\n\nflow control: sender won’t \noverwhelm receiver \n\ndoes not provide: timing, \nminimum throughput \nguarantees, security\nUser Datagram Protocol \n(UDP) service:\n\nunreliable data transfer \nbetween sending and \nreceiving process\n\ndoes not provide: \nconnection setup, reliability, \nflow control, congestion \ncontrol, timing, throughput \nguarantee, or security \nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide43",
    "text": "TCP: Overview\nfull duplex data:\n\nbi-directional data flow in \nsame connection\nconnection-oriented: \n\nhandshaking (exchange \nof control msgs) \nflow controlled:\n\nsender will not overwhelm \nreceiver\npoint-to-point\n\none sender, one receiver \nreliable, in-order byte \nsteam\nPipelined\nsend & receive buffers\n!\"#$%C\n'\"\"(\n)*+\n!%,'-./00%(\n)*+\n(%#%12%-./00%(\n!\"#$%C\n'\"\"(\n!%P4%,C\n566T1#5C1\",\n8(1C%!-'5C5\n566T1#5C1\",\n(%5'!-'5C5\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide44",
    "text": "TCP Segment Format\n!\"#A%CD(F*H,AH-.L0\nNH#H\nOPL45DS7\nU,49%,#\nND#9%,#\nW;,<LC\n=\n>.H?D\n@,?9#,\nA;*L,#ADL;BAC;%C\nULaSLC4LbS7\nA45C%C.L;?7LC#\n=\nc\nd=\nde\nId\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide45",
    "text": "Segment Format (cont)\nEach connection identified with 4-tuple:\n\n(SrcPort, SrcIPAddr, DsrPort, DstIPAddr)\nSliding window + flow control\n\nacknowledgment, SequenceNum, AdvertisedWinow\nFlags\n\nSYN, FIN, RESET, PUSH, URG, ACK\nChecksum\n\npseudo header + TCP header + data\n!\"#A\"%\n&D(D )!\"*+\"#,\"-+./\n0,N#234\"AR.\"#(S7\n0A8\"%(9W\"A;9#A23\n<\",\"98\"%\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide46",
    "text": "TCP Connection Management\nRecall: TCP sender, receiver \nestablish “connection” before \nexchanging data segments\n\ninitialize TCP variables:\n\nseq. #s\n\nbuffers, flow control info \n\nclient: connection initiator\n\nserver: contacted by client\nThree way handshake:\nStep 1: client host sends TCP \nSYN segment to server\n\nspecifies initial seq #\n\nno data\nStep 2: server host receives SYN, \nreplies with SYNACK segment\n\nspecifies server initial seq. #\nStep 3: client receives SYNACK, \nreplies with ACK segment, \nwhich may contain data\nFrom Computer Networking by Kurose and Ross.\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide47",
    "text": "Connection Setup\n47\nWhy do we need connection setup?\n\nTo establish state on both hosts\n\nMost important state: sequence numbers\n\nCount the number of bytes that have been sent\n\nInitial value chosen at random\n\nWhy?\nImportant TCP flags (1 bit each)\n\nSYN – synchronization, used for connection setup\n\nACK – acknowledge received data\n\nFIN – finish, used to tear down connection\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide48",
    "text": "Three Way Handshake\n48\nEach side:\nNotifies the other of starting sequence number\nACKs the other side’s starting sequence number\nClient\nServer\nSYN <SeqC, 0>\nSYN/ACK <SeqS, SeqC+1>\nACK <SeqC+1, SeqS+1>\nWhy\nSequence # +1?\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide49",
    "text": "Connection Setup Issues\n49\nConnection confusion\n\nHow to disambiguate connections from the same \nhost?\n\nRandom sequence numbers\nSource spoofing\n\nNeed good random number generators!\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide50",
    "text": "Connection Tear Down\n53\nEither side can initiate tear \ndown\nOther side may continue \nsending data\n\nHalf open connection\n\nshutdown()\nAcknowledge the last FIN\n\nSequence number + 1\nWhat happens if 2nd FIN is \nlost?\nClient\nServer\nFIN <SeqA, *>\nACK <*, SeqA+1>\nACK\nData\nFIN <SeqB, *>\nACK <*, SeqB+1>\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide51",
    "text": "Bidirectional Communication\n55\nEach side of the connection can send and receive\nDifferent sequence numbers for each direction\nClient\nServer\nData (1460 bytes)\nData/ACK (730 bytes)\nData/ACK (1460 bytes)\nSeq.\nAck.\nSeq.\nAck.\n1\n23\n23\n1461\n1461\n753\n753\n2921\nData and ACK in \nthe same packet\n23\n1\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide52",
    "text": "User Datagram Protocol (UDP)\n56\nSimple, connectionless datagram\nPort numbers enable demultiplexing\n\n16 bits = 65535 possible ports\n\nPort 0 is invalid\nChecksum for error detection\n\nDetects (some) corrupt packets\n\nDoes not detect dropped, duplicated, or reordered packets\nDestination Port\n0\n16\n31\nMessage Length\nSource Port\nChecksum\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide53",
    "text": "Simple Demultiplexor (UDP)\nUnreliable and unordered datagram service\nNo flow control or error control\n\nno need for sender-side buffer\nEndpoints identified by ports\nHeader format\nOptional checksum\n\npsuedo header (IP.src, IP.dsest, IP.proto, UDP.len) + UDP \nheader + data\n!\"#$%\"C\nD(C$%\"C\n)*+#,(-.\nL+01C*\nD2C2\nP\n45\nS4\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide54",
    "text": "Uses for UDP\n58\nInvented after TCP\n\nWhy?\nNot all applications can tolerate TCP\nCustom protocols can be built on top of UDP\n\nReliability? Strict ordering?\n\nFlow control? Congestion control?\nExamples\n\nLive media streaming (e.g. voice, video)\n\nFacebook datacenter protocol\n"
  },
  {
    "doc": "lecture02_processed.json",
    "id": "slide55",
    "text": "TCP vs UDP\nhttps://www.youtube.com/watch?v=cA9ZJdqzOoU\n"
  }
]